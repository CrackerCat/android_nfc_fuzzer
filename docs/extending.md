# Extending the fuzzer

The fuzzer can be extended to other types of NFC tags. The `TestDetect` function used in the harness sets up the envoirnment that is suitable for fuzzing other types of tag read/write under `system/nfc/src/nfc/tags` in the aosp source tree:

```cpp
void TestDetect(const nfc::DetectSession& session) {
  setup(NFC_PROTOCOL_T2T);
  nfa_rw_start_ndef_detection();
  nfa_rw_cb.cur_op = NFA_RW_OP_READ_NDEF;
  handleT2T(session);
  deactivate();
}
```

To set up for other protocol, just replace `NFC_PROTOCOL_T2T` by a macro appropriate for that protocol. To test other operations other than tag read, (e.g. format, set read only, write), remove the `nfa_rw_cb.cur_op = NFA_RW_OP_READ_NDEF` line.

After that, the crucial point is to replace the processing logic by ones that are appropriate for the corresponding protocol (i.e. `create_t2t_wait_cc`, `create_t2t_wait_select_sector`, `create_t2t_default_response`) For experiment, You can try to just use the `create_t2t_wait_select_sector` function:

```cpp
void create_t2t_wait_select_sector(const nfc::WaitSelectSector& df, NFC_HDR** p_msgs) {
  size_t data_len = cap_data_len(df.data().length());
  NFC_HDR* p_msg = create_data_msg_meta(data_len, df.data().c_str());
  if (p_msg == NULL) return;
  p_msg->len = (uint16_t)(data_len);
  //copy the rest of the data
  if (data_len > 3)
    memcpy((uint8_t*)(p_msg + 1) + p_msg->offset + 3, df.data().c_str() + 3, data_len - 3);
  p_msgs[0] = p_msg;
  return;
}
```

As this will just fuzz with data of any length generated by the fuzzer and take care of the necessary meta data (first 3 bytes in the payload) that is necessary for the payload to be accepted. Using this is probably not optimal and may take longer for fuzzing. To be better results, more effort may be needed to create custom protobuf messages and custom processors.
